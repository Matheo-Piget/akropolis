Mathéo :

    -création d'un fonction pour assombrir une texture :
        Cette méthode est utilisée pour assombrir une texture. Elle prend en entrée une texture (`TexturePaint`) et un nombre entier (`floor`). Voici comment elle fonctionne :

        1. Elle récupère l'image de la texture.
        2. Elle crée une nouvelle image (`darkImg`) de la même taille que l'image originale, mais avec un format de couleur ARGB (Alpha, Rouge, Vert, Bleu).
        3. Elle parcourt chaque pixel de l'image originale.
        4. Pour chaque pixel, elle récupère sa couleur.
        5. Elle assombrit la couleur du pixel autant de fois que spécifié par le paramètre `floor`.
        6. Elle définit la couleur du pixel correspondant dans `darkImg` à la nouvelle couleur assombrie.
        7. Finalement, elle retourne une nouvelle texture qui utilise `darkImg` comme image et qui a le même rectangle d'ancrage que la texture originale.

        En résumé, cette méthode assombrit chaque pixel d'une texture donnée un certain nombre de fois, puis retourne la nouvelle texture assombrie.
Nidhal :
    -Terminer le score pour chaque type de district :
        1.ajoute de la fonction placeDeTypeS pour avoir  tout les places (qui sont vivsibles ) de chaque type de district
        2.ajoute de la fonction nbetoile pour savoir le nombre des etoiles des ces places et les multiplier par le score de chaque hexagone de type district(en respecant les regles) qui sera ajouté au score totale (qui sera calculer plus tard en parcourant chaque hexagone)
    - par exemple le calcul du score le plus dure en détail: 
        Début du processus : Pour chaque hexagone de type "Building", on démarre le calcul du score de connectivité.
            Appel de méthode : calculateBuildingScore est appelé avec l'hexagone actuel, lançant la procédure.
            Marquage des visités : À l'intérieur de visitBuildingHex, si l'hexagone n'a pas encore été visité, il est ajouté à la liste de marquage pour prévenir des revisites.
            Calcul récursif : Le score est incrémenté pour l'hexagone actuel. Ensuite, visitBuildingHex est appelée récursivement pour tous ses voisins de type "Building", qui ne sont pas encore visités, incluant les voisins des voisins, et ainsi de suite.
            Comparaison et conservation du score : Après avoir calculé le score pour un cluster, si ce score est supérieur au score le plus élevé précédemment enregistré (lastbuildingS), il devient le nouveau score le plus élevé.
            Résultat final : Le score du plus grand groupe connecté de bâtiments est ajouté au score total à la fin du parcours de la grille final on garde et rajoute le plus grand à la fin 
Bilal :
    Création des classes GridView, HexagoneView avec ces sous composantes. QuarrieView, PlaceView et DistrictView héritent tous de la classe abstraite HexagonView.
    HexagonView extend de Polygon et permet simplement de tracer les hexagons en définissant ces points. La méthode abstraite paint que toutes les classes enfants devront implémenter pour
    créer l'objet graphique et l'afficher (la méthode fill de java Graphics aide beaucoup). Il y a aussi un antialiasing même si pas incroyable (les bords des hexagons sont toujours un peu "jaggy").
    GridView itère pour paint sur chaque poly stocké dans une ArrayList et les dessinent en reliant donc les points prédéfinis. 
    Notons que le passage à des coordonnées axiale est EXTREMENT pratique puisque l'on a besoin simplement d'une petite formule pour convertir les positions de la grille de jeu en pixel.
    La formule est la suivante pour des hexagones plat en haut (la formule varie pour l'autre forme) :
    int pixelX = (int) (size * 3.0 / 2 * q) + xOffset;
    int pixelY = (int) (size * Math.sqrt(3) * (r + q / 2.0)) + yOffset;
    L'offset est simplement le centre de la grille de jeu (on divise par 2 la taille du Panel pour l'obtenir).
    Le tracage de l'hexagone se fait en faisant un peu de maths graĉe à cette boucle :
    for (int i = 0; i < 6; i++) {
            int xval = (int) (center + center * Math.cos(i * 2 * Math.PI / 6));
            int yval = (int) (center + center * Math.sin(i * 2 * Math.PI / 6));
            hexagon.addPoint(xval, yval);
        }
    Remarquons qu'on utilise la formule de conversion des coordonnées polaires en coordonnées cartésiennes : x = r * cos(theta) et y = r * sin(theta). 
    Ici, r est le rayon (la distance du centre de l'hexagone au point), qui est égal à center, et theta est l'angle, qui est i * 2 * Math.PI / 6. 
    Comme il y a 2*PI radians dans un cercle complet et que l'hexagone a six points, chaque point est à 2 * Math.PI / 6 radians du précédent.